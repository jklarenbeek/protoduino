/**
 * @file src/lib/loader/loader.h
 * @brief Dynamic module loader for Protoduino
 *
 * Adapted from Contiki-OS loader library for Arduino/AVR platforms
 * Supports loading compiled modules at runtime via serial command line
 */

#ifndef __LOADER_H__
#define __LOADER_H__

#include <protoduino.h>
#include <avr/pgmspace.h>

// Module status codes
#define LOADER_OK                   0
#define LOADER_ERR_NOLOADER        -1
#define LOADER_ERR_NOTFOUND        -2
#define LOADER_ERR_READ            -3
#define LOADER_ERR_HDR             -4
#define LOADER_ERR_OS              -5
#define LOADER_ERR_FMT             -6
#define LOADER_ERR_NOMEM           -7
#define LOADER_ERR_NONAME          -8

// Maximum number of loadable modules
#ifndef LOADER_MAX_MODULES
#define LOADER_MAX_MODULES 4
#endif

// Maximum symbol table size
#ifndef LOADER_MAX_SYMBOLS
#define LOADER_MAX_SYMBOLS 32
#endif

// Module flags
#define LOADER_FLAG_RUNNING  0x01
#define LOADER_FLAG_AUTORUN  0x02

/**
 * @brief Symbol table entry
 */
struct loader_symbol {
    const char *name;      // Symbol name (in PROGMEM)
    void *addr;            // Symbol address
};

/**
 * @brief Module descriptor
 */
struct loader_module {
    struct pt pt;          // Protothread for module execution
    char name[16];         // Module name
    void *code;            // Code segment address
    void *data;            // Data segment address
    uint16_t code_size;    // Code segment size
    uint16_t data_size;    // Data segment size
    uint8_t flags;         // Module flags
    ptstate_t (*entry)(struct pt *); // Entry point
};

/**
 * @brief Loader context
 */
struct loader_ctx {
    struct loader_module modules[LOADER_MAX_MODULES];
    struct loader_symbol symbols[LOADER_MAX_SYMBOLS];
    uint8_t num_modules;
    uint8_t num_symbols;
};

// Global loader context
extern struct loader_ctx loader;

/**
 * @brief Initialize the loader subsystem
 */
CC_EXTERN void loader_init(void);

/**
 * @brief Load a module from a stream (e.g., serial)
 *
 * @param name Module name
 * @param stream Stream to read module data from
 * @return LOADER_OK on success, negative error code on failure
 */
CC_EXTERN int loader_load(const char *name, Stream *stream);

/**
 * @brief Unload a module
 *
 * @param name Module name
 * @return LOADER_OK on success, negative error code on failure
 */
CC_EXTERN int loader_unload(const char *name);

/**
 * @brief Start a loaded module
 *
 * @param name Module name
 * @return LOADER_OK on success, negative error code on failure
 */
CC_EXTERN int loader_start(const char *name);

/**
 * @brief Stop a running module
 *
 * @param name Module name
 * @return LOADER_OK on success, negative error code on failure
 */
CC_EXTERN int loader_stop(const char *name);

/**
 * @brief Get module by name
 *
 * @param name Module name
 * @return Pointer to module or NULL if not found
 */
CC_EXTERN struct loader_module *loader_get_module(const char *name);

/**
 * @brief Register a symbol in the global symbol table
 *
 * @param name Symbol name (must be in PROGMEM)
 * @param addr Symbol address
 * @return LOADER_OK on success, negative error code on failure
 */
CC_EXTERN int loader_register_symbol(const char *name, void *addr);

/**
 * @brief Lookup a symbol by name
 *
 * @param name Symbol name
 * @return Symbol address or NULL if not found
 */
CC_EXTERN void *loader_lookup_symbol(const char *name);

/**
 * @brief Schedule all running modules
 *
 * Call this from your main loop to execute loaded modules
 */
CC_EXTERN void loader_schedule(void);

/**
 * @brief Print loader status
 *
 * @param stream Output stream
 */
CC_EXTERN void loader_print_status(Stream *stream);

/**
 * @brief Macro to register exported functions
 *
 * Use this to export functions that modules can call
 */
#define LOADER_EXPORT_SYMBOL(name) \
    loader_register_symbol(PSTR(#name), (void *)name)

#endif /* __LOADER_H__ */