/**
 * @file src/lib/loader/loader.c
 * @brief Dynamic module loader implementation
 */

#include "loader.h"
#include <string.h>
#include <stdlib.h>

// Global loader context
struct loader_ctx loader;

// Simple ELF header structure (simplified for AVR)
struct elf_header {
    uint8_t  magic[4];      // ELF magic number
    uint8_t  class;         // 32/64 bit
    uint8_t  data;          // Endianness
    uint8_t  version;       // ELF version
    uint8_t  padding[9];    // Padding
    uint16_t type;          // Object file type
    uint16_t machine;       // Architecture
    uint32_t version2;      // ELF version
    uint32_t entry;         // Entry point
    uint32_t phoff;         // Program header offset
    uint32_t shoff;         // Section header offset
};

void loader_init(void)
{
    memset(&loader, 0, sizeof(loader));

    // Register core Protoduino functions
    // These will be available to all loaded modules
    LOADER_EXPORT_SYMBOL(delay);
    LOADER_EXPORT_SYMBOL(millis);
    LOADER_EXPORT_SYMBOL(micros);

    // Add more exported symbols as needed
}

int loader_register_symbol(const char *name, void *addr)
{
    if (loader.num_symbols >= LOADER_MAX_SYMBOLS)
        return LOADER_ERR_NOMEM;

    loader.symbols[loader.num_symbols].name = name;
    loader.symbols[loader.num_symbols].addr = addr;
    loader.num_symbols++;

    return LOADER_OK;
}

void *loader_lookup_symbol(const char *name)
{
    for (uint8_t i = 0; i < loader.num_symbols; i++) {
        if (strcmp_P(name, loader.symbols[i].name) == 0) {
            return loader.symbols[i].addr;
        }
    }
    return NULL;
}

struct loader_module *loader_get_module(const char *name)
{
    for (uint8_t i = 0; i < loader.num_modules; i++) {
        if (strcmp(loader.modules[i].name, name) == 0) {
            return &loader.modules[i];
        }
    }
    return NULL;
}

int loader_load(const char *name, Stream *stream)
{
    // Check if module already loaded
    if (loader_get_module(name) != NULL)
        return LOADER_ERR_OS;

    // Check if we have space
    if (loader.num_modules >= LOADER_MAX_MODULES)
        return LOADER_ERR_NOMEM;

    struct loader_module *mod = &loader.modules[loader.num_modules];

    // Copy module name
    strncpy(mod->name, name, sizeof(mod->name) - 1);
    mod->name[sizeof(mod->name) - 1] = '\0';

    // Read ELF header (simplified)
    struct elf_header hdr;
    size_t read = stream->readBytes((uint8_t *)&hdr, sizeof(hdr));

    if (read < sizeof(hdr))
        return LOADER_ERR_READ;

    // Verify ELF magic
    if (hdr.magic[0] != 0x7F ||
        hdr.magic[1] != 'E' ||
        hdr.magic[2] != 'L' ||
        hdr.magic[3] != 'F')
        return LOADER_ERR_HDR;

    // For simplicity, we'll use a fixed format:
    // - First 2 bytes: code size
    // - Next 2 bytes: data size
    // - Code segment
    // - Data segment
    // - Relocation table

    uint16_t code_size, data_size;
    stream->readBytes((uint8_t *)&code_size, 2);
    stream->readBytes((uint8_t *)&data_size, 2);

    // Allocate memory for code and data
    mod->code = malloc(code_size);
    mod->data = malloc(data_size);

    if (!mod->code || (data_size > 0 && !mod->data)) {
        free(mod->code);
        free(mod->data);
        return LOADER_ERR_NOMEM;
    }

    mod->code_size = code_size;
    mod->data_size = data_size;

    // Read code segment
    if (stream->readBytes((uint8_t *)mod->code, code_size) < code_size) {
        free(mod->code);
        free(mod->data);
        return LOADER_ERR_READ;
    }

    // Read data segment
    if (data_size > 0) {
        if (stream->readBytes((uint8_t *)mod->data, data_size) < data_size) {
            free(mod->code);
            free(mod->data);
            return LOADER_ERR_READ;
        }
    }

    // Set entry point (first address in code segment)
    mod->entry = (ptstate_t (*)(struct pt *))mod->code;

    // Initialize module protothread
    PT_INIT(&mod->pt);

    mod->flags = 0;
    loader.num_modules++;

    return LOADER_OK;
}

int loader_unload(const char *name)
{
    struct loader_module *mod = loader_get_module(name);
    if (!mod)
        return LOADER_ERR_NOTFOUND;

    // Stop module if running
    if (mod->flags & LOADER_FLAG_RUNNING)
        loader_stop(name);

    // Free memory
    free(mod->code);
    free(mod->data);

    // Compact module array
    uint8_t idx = mod - loader.modules;
    for (uint8_t i = idx; i < loader.num_modules - 1; i++) {
        loader.modules[i] = loader.modules[i + 1];
    }
    loader.num_modules--;

    return LOADER_OK;
}

int loader_start(const char *name)
{
    struct loader_module *mod = loader_get_module(name);
    if (!mod)
        return LOADER_ERR_NOTFOUND;

    if (mod->flags & LOADER_FLAG_RUNNING)
        return LOADER_OK; // Already running

    PT_INIT(&mod->pt);
    mod->flags |= LOADER_FLAG_RUNNING;

    return LOADER_OK;
}

int loader_stop(const char *name)
{
    struct loader_module *mod = loader_get_module(name);
    if (!mod)
        return LOADER_ERR_NOTFOUND;

    mod->flags &= ~LOADER_FLAG_RUNNING;
    PT_INIT(&mod->pt); // Reset protothread

    return LOADER_OK;
}

void loader_schedule(void)
{
    for (uint8_t i = 0; i < loader.num_modules; i++) {
        struct loader_module *mod = &loader.modules[i];

        if (mod->flags & LOADER_FLAG_RUNNING) {
            ptstate_t state = mod->entry(&mod->pt);

            // Handle module completion
            if (state == PT_ENDED || state == PT_EXITED) {
                mod->flags &= ~LOADER_FLAG_RUNNING;
            }
        }
    }
}

void loader_print_status(Stream *stream)
{
    stream->print(F("Loaded modules: "));
    stream->println(loader.num_modules);
    stream->println();

    for (uint8_t i = 0; i < loader.num_modules; i++) {
        struct loader_module *mod = &loader.modules[i];

        stream->print(F("  ["));
        stream->print(i);
        stream->print(F("] "));
        stream->print(mod->name);
        stream->print(F(" (code: "));
        stream->print(mod->code_size);
        stream->print(F(", data: "));
        stream->print(mod->data_size);
        stream->print(F(") "));

        if (mod->flags & LOADER_FLAG_RUNNING)
            stream->print(F("[RUNNING]"));
        else
            stream->print(F("[STOPPED]"));

        stream->println();
    }

    stream->println();
    stream->print(F("Free RAM: "));

    // Calculate free RAM (AVR specific)
    extern int __heap_start, *__brkval;
    int v;
    int free_ram = (int) &v - (__brkval == 0 ? (int) &__heap_start : (int) __brkval);
    stream->print(free_ram);
    stream->println(F(" bytes"));
}